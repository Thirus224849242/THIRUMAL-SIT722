name: CD ‚Äì Staging Deploy & Teardown

on:
  workflow_run:
    workflows: ["CI Test, Build & Push to ACR (testing branch)"]
    types:
      - completed

jobs:
  deploy-staging:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --name ${{ secrets.AKS_CLUSTER_NAME }} \
            --resource-group ${{ secrets.AKS_RESOURCE_GROUP }} \
            --overwrite-existing

      - name: Create staging namespace
        run: |
          kubectl create namespace staging --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply configs & secrets
        run: |
          kubectl apply -n staging -f k8s/configmaps.yaml || true
          kubectl apply -n staging -f k8s/secrets.yaml || true

      - name: Deploy all services
        run: |
          kubectl apply -n staging -f k8s/

      - name: Wait for Pods to be Ready (with retries & debug)
        run: |
          set +e
          for i in {1..8}; do
            echo "üîÑ Attempt $i to wait for deployments..."
            kubectl wait --for=condition=available --timeout=90s deployment --all -n staging
            STATUS=$?
            if [ $STATUS -eq 0 ]; then
              echo "‚úÖ All deployments are available!"
              exit 0
            fi
            echo "‚ùå Pods not ready yet. Dumping debug info..."
            kubectl get pods -n staging -o wide
            kubectl get deploy -n staging
            kubectl get events -n staging --sort-by=.lastTimestamp | tail -n 20
            sleep 60
          done
          exit 1

      - name: Wait for backend LoadBalancer IPs
        id: get-ips
        run: |
          echo "Fetching backend service IPs..."
          for svc in product-service order-service customer-service; do
            for i in {1..20}; do
              IP=$(kubectl get svc $svc -n staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
              if [[ -n "$IP" ]]; then
                echo "$svc external IP: $IP"
                break
              fi
              echo "$svc still pending... retrying in 15s (attempt $i)"
              sleep 15
            done
            if [[ -z "$IP" ]]; then
              echo "‚ùå $svc did not get an external IP in time."
              exit 1
            fi
            if [[ "$svc" == "product-service" ]]; then
              echo "product_api_ip=http://$IP:8000" >> $GITHUB_OUTPUT
            elif [[ "$svc" == "order-service" ]]; then
              echo "order_api_ip=http://$IP:8001" >> $GITHUB_OUTPUT
            elif [[ "$svc" == "customer-service" ]]; then
              echo "customer_api_ip=http://$IP:8002" >> $GITHUB_OUTPUT
            fi
          done

      - name: Inject Backend IPs into Frontend
        run: |
          sed -i "s|_PRODUCT_API_URL_|${{ steps.get-ips.outputs.product_api_ip }}|g" frontend/main.js
          sed -i "s|_ORDER_API_URL_|${{ steps.get-ips.outputs.order_api_ip }}|g" frontend/main.js
          sed -i "s|_CUSTOMER_API_URL_|${{ steps.get-ips.outputs.customer_api_ip }}|g" frontend/main.js
          echo "--- Modified main.js ---"
          head -n 20 frontend/main.js
          
      - name: Login to Azure Container Registry
        run: az acr login --name ${{ secrets.AZURE_CONTAINER_REGISTRY }}

      - name: Rebuild & Push Frontend with injected IPs
        run: |
          docker build -t ${{ secrets.AZURE_CONTAINER_REGISTRY }}/frontend:staging ./frontend/
          docker push ${{ secrets.AZURE_CONTAINER_REGISTRY }}/frontend:staging

      - name: Redeploy Frontend with updated image
        run: |
          kubectl set image deployment/frontend frontend=${{ secrets.AZURE_CONTAINER_REGISTRY }}/frontend:staging -n staging
          kubectl rollout status deployment/frontend -n staging --timeout=300s

      - name: Get Frontend IP & Smoke Test
        run: |
          echo "üîç Waiting for frontend LoadBalancer IP..."
          for i in {1..10}; do
            FRONTEND_IP=$(kubectl get svc frontend-service -n staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -n "$FRONTEND_IP" ]; then
              echo "‚úÖ Frontend IP acquired: $FRONTEND_IP"
              curl -s http://$FRONTEND_IP/health && exit 0
            fi
            echo "‚ö†Ô∏è No IP yet, retrying in 30s... (attempt $i)"
            sleep 30
          done
          echo "‚ùå Frontend IP not assigned after waiting."
          kubectl get svc -n staging
          exit 1

  teardown-staging:
    needs: deploy-staging
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --name ${{ secrets.AKS_CLUSTER_NAME }} \
            --resource-group ${{ secrets.AKS_RESOURCE_GROUP }} \
            --overwrite-existing

      - name: Delete staging namespace
        run: kubectl delete namespace staging --ignore-not-found
